---
title: "`chipenrich`: Gene Set Enrichment For ChIP-seq Peak Data"
author: "Ryan P. Welch, Chee Lee, Raymond G. Cavalcante, Chris Lee, Laura J. Scott, Maureen A. Sartor"
date: "`r Sys.Date()`"
output:
  BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{chipenrich_vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Introduction

Gene set enrichment (GSE) testing enables the interpretation of ChIP-seq data in terms of pathways and other biologically meaningful sets of genes. The `chipenrich` package performs GSE on ChIP-seq data while accounting for biases that are known to effect the Type I error of such testing. In particular, the length of a gene affects the probability that a peak will be assigned to it. If this bias is not corrected, GSE results will often have inflated Type I error, and preferentially find gene sets with longer genes to be significant.

The `chipenrich` package includes three classes of methods that adjust for this confounding:

* `broadenrich()` is designed for use with histone modification (HM) based ChIP-seq data resulting in broad peaks.
* `chipenrich()` is designed for use with transcription factor (TF) based ChIP-seq data resulting in narrow peaks.
* `polyenrich()` is also designed for TF data resulting in narrow peaks, but where the number of peaks in a gene may be of regulatory importance.

# Concepts

This section defines terms and methods used in the package.

## Peaks

A ChIP-seq peak is a genomic region that represents a transcription factor binding event or the presence of a histone complex with a particular histone modification. Typically peaks are called with a peak caller (such as [MACS2](https://github.com/taoliu/MACS) or [PePr](https://github.com/shawnzhangyx/PePr/)) and represent relative enrichment of reads in a sample where the antibody is present versus input. Typically, peaks are output by a peak caller in [`BED`-like](https://genome.ucsc.edu/FAQ/FAQformat.html) format.

## Locus Definitions

A locus definition is a way of assigning peaks to genes. A trivial locus definition might be the gene body from the transcription start site (TSS) to the transcript end site (TES). A locus definition can also express how one expects a transcription factor to regulate genes. For example, a locus definition defined as 1kb upstream and downstream of a TSS would capture TFs that bind in promoter regions.

## Gene Sets

Gene sets are sets of genes that represent a particular biological function. Popular gene sets that are used by `chipenrich` include [KEGG Pathways](http://www.kegg.jp), [Gene Ontology](http://geneontology.org), and [Reactome Pathways](http://www.reactome.org).

## Mappability

We define base pair mappability as the average read mappability of all possible reads of size K that encompass a specific base pair location, $b$. Mappability files from UCSC Genome Browser mappability track were used to calculate base pair mappability. The mappability track provides values for theoretical read mappability, or the number of places in the genome that could be mapped by a read that begins with the base pair location $b$. For example, a value of 1 indicates a Kmer read beginning at $b$ is mappable to one area in the genome. A value of 0.5 indicates a Kmer read beginning at $b$ is mappable to two areas in the genome. For our purposes, we are only interested in uniquely mappable reads; therefore, all reads with mappability less than 1 were set to 0 to indicate non-unique mappability. Then, base pair mappability is calculated as:

$$
\begin{equation}
M_{i} = (\frac{1}{2K-1}) \sum_{j=i-K+1}^{i+(K-1)} M_{j}
\end{equation}
$$

where $M_{i}$ is the mappability of base pair $i$, and $M_{j}$ is mappability (from UCSC's mappability track) of read $j$ where j is the start position of the K length read.

## Methods for GSE

As stated in the introduction, the `chipenrich` package includes three classes of methods for doing gene set enrichment testing:

### `broadenrich()`

Broad-Enrich is designed for broad genomic regions, as one often gets from ChIP-seq experiments on histone modifications. The Broad-Enrich method uses the cumulative peak coverage of genes in its logistic regression model for enrichment: `GO ~ ratio + s(log10_length)`. Here, `GO` is a binary vector indicating whether a gene is in the gene set being tested, `ratio` is a numeric vector indicating the ratio of the gene covered by peaks, and `s(log10_length)` is a binomial cubic smoothing spline which adjusts for the relationship between gene coverage and locus length.

### `chipenrich()`

ChIP-Enrich is designed for datasets with narrow peaks. The ChIP-Enrich method uses the presence of a peak in its logistic regression model for enrichment: `peak ~ GO + s(log10_length)`. Here, `GO` is a binary vector indicating whether a gene is in the gene set being tested, `peak` is a binary vector indicating the presence of a peak in a gene, and `s(log10_length)` is a binomial cubic smoothing spline which adjusts for the relationship between the presence of a peak and locus length.

### `polyenrich()`

Poly-Enrich is designed for datasets where multiple peaks in a gene should be taken into account. The Poly-Enrich method uses the number of peaks in genes in its logistic regression model for enrichment: `num_peaks ~ GO + s(log10_length)`. Here, `GO` is a binary vector indicating whether a gene is in the gene set being tested, `num_peaks` is a numeric vector indicating the number of peaks in each gene, and `s(log10_length)` is a binomial cubic smoothing spline which adjusts for the relationship between the number of peaks in a gene and locus length.

### Choosing a method

HERE IS WHERE WE'D TALK ABOUT RECOMMENDATIONS FOR WHICH METHOD TO USE...?

## Assessing Type I Error with Randomizations

Randomization of locus definitions allows for the assessment of Type I Error under the null hypothesis of no true gene set enrichment. A well-calibrated Type I Error means that the false positive rate is controlled, and the p-values reported for actual data can be trusted. In both Welch & Lee, et al. and Cavalcante, et al., we demonstrated that both `chipenrich()` and `broadenrich()` have well-calibrated Type I Error over dozens of publicly available ENCODE ChIP-seq datasets. Unpublished data suggests the same is true for `polyenrich()`.

We have implemented three types of randomizations,

* `complete`: Shuffle the `gene_id` and `symbol` columns of the `locusdef` without regard for the chromosome location, or locus length. The null hypothesis is that there is no true gene set enrichment. An incorrect Type I error with this randomization indicates that a different enrichment test should be used.
* `bylength`: Shuffle the `gene_id` and `symbol` columns of the `locusdef` within bins of 100 genes sorted by locus length. The null hypothesis is that there is no true gene set enrichment, but with preserved locus length relationship. An incorrect Type I Error with this randomization indicates that the relationship between the presence of a peak and the locus length is influencing the Type I Error.
* `bylocation`: Shuffle the `gene_id` and `symbol` columns of the `locusdef` within bins of 50 genes sorted by genomic location. The null hypothesis is that there is no true gene set enrichment, but with preserved genomic location. An incorrect Type I Error with this randomization indicates that the genomic proximity of genes is influencing the Type I Error.

# Implementation

This section will highlight the workflow and implementation details for doing gene set enrichment testing with `chipenrich`. First, load the package:

```{r}
library(chipenrich)
```

## Peaks

The primary user input for `chipenrich()`, `broadenrich()`, or `polyenrich()` are the genomic regions representing the peaks to be used for enrichment testing. Peaks can be input as either a file path or a `data.frame`.

If a file path, the following formats are fully supported via their file extensions: `.bed`, `.broadPeak`, `.narrowPeak`, `.gff3`, `.gff2`, `.gff`, and `.bedGraph` or `.bdg`. BED3 through BED6 files are supported under the `.bed` extension ([BED specification](https://genome.ucsc.edu/FAQ/FAQformat.html)). Files without these extensions are supported under the conditions that the first 3 columns correspond to `chr`, `start`, and `end` and that there is either no header column, or it is commented out. Files may be compressed with `gzip`, and so might end in `.narrowPeak.gz`, for example. For files with extension support, the `rtracklayer::import()` function is used to read peaks, so adherence to the mentioned file formats is necessary.

If peaks are already in the R environment as a `data.frame`, the `GenomicRanges::makeGRangesFromDataFrame()` function is used to convert to a `GRanges` object. For the acceptable column names needed for correct interpretation, see `?GenomicRanges::makeGRangesFromDataFrame`.

For the purpose of the vignette, we'll load some peaks from the `chipenrich.data` companion package:

```{r, warning = FALSE, message = FALSE}
data(peaks_E2F4, package = 'chipenrich.data')
data(peaks_H3K4me3_GM12878, package = 'chipenrich.data')

head(peaks_E2F4)
head(peaks_H3K4me3_GM12878)
```

```{r, echo=FALSE}
#peaks_E2F4 = subset(peaks_E2F4, peaks_E2F4$chrom == 'chr1')
#peaks_H3K4me3_GM12878 = subset(peaks_H3K4me3_GM12878, peaks_H3K4me3_GM12878$chrom == 'chr1')
```

## Genomes

Genomes for fly, human, mouse, rat, and zebrafish are supported. Particular supported genome builds are given by:

```{r}
supported_genomes()
```

## Locus Definitions

### Built-in locus definitions

A number of locus definitions representing different regulatory paradigms are included in the package:

* `nearest_tss`: The locus is the region spanning the midpoints between the TSSs of adjacent genes.
* `nearest_gene`: The locus is the region spanning the midpoints between the boundaries of each gene, where a gene is defined as the region between the furthest upstream TSS and furthest downstream TES for that gene. If gene loci overlap, the midpoint of the overlap is used as a border. If a gene locus is nested in another, the larger locus is split in two.
* `exon`: Each gene has multiple loci corresponding to its exons. Overlaps between different genes are allowed.
* `intron`: Each gene has multiple loci corresponding to its introns. Overlaps between different genes are allowed.
* `1kb`: The locus is the region within 1kb of any of the TSSs belonging to a gene. If TSSs from two adjacent genes are within 2 kb of each other, we use the midpoint between the two TSSs as the boundary for the locus for each gene.
* `1kb_outside_upstream`: The locus is the region more than 1kb upstream from a TSS to the midpoint between the adjacent TSS.
* `1kb_outside`: The locus is the region more than 1kb upstream or downstream from a TSS to the midpoint between the adjacent TSS.
* `5kb`: The locus is the region within 5kb of any of the TSSs belonging to a gene. If TSSs from two adjacent genes are within 10 kb of each other, we use the midpoint between the two TSSs as the boundary for the locus for each gene.
* `5kb_outside_upstream`: The locus is the region more than 5kb upstream from a TSS to the midpoint between the adjacent TSS.
* `5kb_outside`: The locus is the region more than 5kb upstream or downstream from a TSS to the midpoint between the adjacent TSS.
* `10kb`: The locus is the region within 10kb of any of the TSSs belonging to a gene. If TSSs from two adjacent genes are within 20 kb of each other, we use the midpoint between the two TSSs as the boundary for the locus for each gene.
* `10kb_outside_upstream`: The locus is the region more than 10kb upstream from a TSS to the midpoint between the adjacent TSS.
* `10kb_outside`: The locus is the region more than 10kb upstream or downstream from a TSS to the midpoint between the adjacent TSS.

The complete listing of genome build and locus definition pairs can be listed with `supported_locusdefs()`:

```{r}
# Take head because it's long
head(supported_locusdefs())
```

### Custom locus definitions

Users can create custom locus definitions for any of the `supported_genomes()`, and pass the file path as the value of the `locusdef` parameter in `broadenrich()`, `chipenrich()`, or `polyenrich()`. Custom locus definitions should be defined in a tab-delimited text file with column names `chr`, `start`, `end`, and `gene_id`. For example:

```{r, eval=FALSE}
chr	start	end	geneid
chr1	839460	839610	148398
chr1	840040	840190	148398
chr1	840040	840190	57801
chr1	840800	840950	148398
chr1	841160	841310	148398
```

## Gene Sets

### Built-in gene sets

Gene sets for fly, human, mouse, rat, and zebrafish are built in to `chipenrich`. Some organisms have gene sets that others do not, so check with:

```{r}
# Take head because it's long
head(supported_genesets())
```

### Custom gene sets

Users can perform GSE on custom gene sets for any supported organism by passing the file path as the value of `genesets` parameter in `broadenrich()`, `chipenrich()`, or `polyenrich()`. Custom gene set definitions should be defined in a tab-delimited text file with a header. The first column should be the geneset ID or name, and the second column should be the Entrez IDs belonging to the geneset. For example:

```{r, eval=FALSE}
gs_id	gene_id
GO:0006631	30
GO:0006631	31
GO:0006631	32
GO:0006631	33
GO:0006631	34
GO:0006631	35
GO:0006631	36
GO:0006631	37
GO:0006631	51
GO:0006631	131
GO:0006631	183
GO:0006631	207
GO:0006631	208
GO:0006631	215
GO:0006631	225
```

## Mappability

### Built-in mappability

Base pair mappability for reads of lengths 24, 36, 40, 50, 75, and 100 base pairs for `hg19` and for reads of lengths 36, 40, 50, 75, and 100 base pairs `mm9` a included. See the complete list with:

```{r}
# Take head because it's long
head(supported_read_lengths())
```

### Custom mappability

Users can use custom mappability with any built-in locus definition (if, for example, the read length needed is not present), or with a custom locus definition. Custom mappability should be defined in a tab-delimited text file with columns named `gene_id` and `mappa`. Gene IDs should be Entrez Gene IDs, and mappability should be in [0,1]. A check is performed to verify that the gene IDs in the locus definition and mappability overlap by at least 95\%. An example custom mappability file looks like:

```{r, eval=FALSE}
mappa	gene_id
0.8	8487
0.1	84
0.6	91
1	1000
```

## Testing for enrichment

As discussed in the introduction, the `chipenrich` package includes three classes of methods:

* `broadenrich()` is designed for use with histone modification (HM) based ChIP-seq data resulting in broad peaks.
* `chipenrich()` is designed for use with transcription factor (TF) based ChIP-seq data resulting in narrow peaks.
* `polyenrich()` is also designed for TF data resulting in narrow peaks, but where the number of peaks in a gene may be of regulatory importance.

Below are examples of calls to each function.

### `broadenrich()`

```{r, warning = FALSE, message = FALSE}
gs_path = system.file('extdata','vignette_genesets.txt', package='chipenrich')
results = broadenrich(peaks = peaks_H3K4me3_GM12878, genome = 'hg19', genesets = gs_path,
	locusdef = "nearest_tss", qc_plots = FALSE, out_name = NULL, n_cores=1)
results.be = results$results
print(results.be[1:5,1:5])
```

### `chipenrich()`

```{r, warning = FALSE, message = FALSE}
# Without mappability
gs_path = system.file('extdata','vignette_genesets.txt', package='chipenrich')
results = chipenrich(peaks = peaks_E2F4, genome = 'hg19', genesets = gs_path,
	locusdef = "nearest_tss", qc_plots = FALSE, out_name = NULL, n_cores = 1)
results.ce = results$results
print(results.ce[1:5,1:5])
```

```{r, warning = FALSE, message = FALSE}
# With mappability
gs_path = system.file('extdata','vignette_genesets.txt', package='chipenrich')
results = chipenrich(peaks = peaks_E2F4, genome = 'hg19', genesets = gs_path,
	locusdef = "nearest_tss", mappability='24', qc_plots = FALSE,
	out_name = NULL,n_cores=1)
results.cem = results$results
print(results.cem[1:5,1:5])
```

### `polyenrich()`

```{r, warning = FALSE, message = FALSE}
gs_path = system.file('extdata','vignette_genesets.txt', package='chipenrich')
results = polyenrich(peaks = peaks_E2F4, genome = 'hg19', genesets = gs_path,  method = 'polyenrich',
	locusdef = "nearest_tss", qc_plots = FALSE, out_name = NULL, n_cores = 1)
results.pe = results$results
print(results.pe[1:5,1:5])
```

### QC Plots

Each enrich function outputs QC plots if `qc_plots = TRUE`. There are also stand-alone functions to make the QC plots without the need for gene set enrichment testing.

#### Peak distance to TSS distribution

```{r, fig.align='center', fig.cap='E2F4 peak distances to TSS', fig.height=6, fig.width=6, fig.show='hold', warning = FALSE, message = FALSE}
# Output in chipenrich and polyenrich
plot_dist_to_tss(peaks = peaks_E2F4, genome = 'hg19')
```

#### Probability of a peak versus locus length

```{r, fig.align='center', fig.cap='E2F4 chipenrich spline without mappability', fig.height=6, fig.width=6, fig.show='hold', warning = FALSE, message = FALSE}
# Output in chipenrich
plot_spline_length(peaks = peaks_E2F4, locusdef = 'nearest_tss', genome = 'hg19')
```

#### Number of peaks versus locus length

```{r, fig.align='center', fig.cap='E2F4 polyenrich spline without mappability', fig.height=6, fig.width=6, fig.show='hold', warning = FALSE, message = FALSE}
# Output in chipenrich
plot_polyenrich_spline(peaks = peaks_E2F4, locusdef = 'nearest_tss', genome = 'hg19')
```

#### Gene coverage versus locus length

```{r, fig.align='center', fig.cap='H3K4me3 gene coverage', fig.height=6, fig.width=6, fig.show='hold', warning = FALSE, message = FALSE}
# Output in chipenrich
plot_gene_coverage(peaks = peaks_H3K4me3_GM12878, locusdef = 'nearest_tss',  genome = 'hg19')
```

### Output

The output of `broadenrich()`, `chipenrich()`, and `polyenrich()` is a list with components corresponding to each section below. If `out_name` is not `NULL`, then a file for each component will be written to the `out_path` with prefixes of `out_name`.

#### Assigned peaks

Peak assignments are stored in `$peaks`.

```{r}
head(results$peaks)
```

#### Peaks-per-gene

Peak information aggregated over genes is stored in `$peaks_per_gene`.

```{r}
head(results$peaks_per_gene)
```

#### Gene set enrichment results

Gene set enrichment results are stored in `$results`.

```{r}
head(results$results)
```

## Assessing Type I Error with Randomizations

Within `chipenrich()`, `broadenrich()`, and `polyenrich()`, the `randomization` parameters can be used to assess the Type I Error for the data being analyzed.

The randomization codes, and their effects are:

* `NULL`: No randomizations, the default.
* `complete`: Shuffle the `gene_id` and `symbol` columns of the `locusdef` without regard for the chromosome location, or locus length. The null hypothesis is that there is no true gene set enrichment.
* `bylength`: Shuffle the `gene_id` and `symbol` columns of the `locusdef` within bins of 100 genes sorted by locus length. The null hypothesis is that there is no true gene set enrichment, but with preserved locus length relationship.
* `bylocation`: Shuffle the `gene_id` and `symbol` columns of the `locusdef` within bins of 50 genes sorted by genomic location. The null hypothesis is that there is no true gene set enrichment, but with preserved genomic location.

The result of `chipenrich()`, `broadenrich()`, or `polyenrich()` with a selected randomization is the same as without (see above). To assess the Type I error, the `alpha` level for the particular data set can be calculated by dividing the total number of gene sets with p-value < 0.05 by the total number of tests tested. Users may want to perform multiple randomizations for a set of peaks and take the median of the `alpha` values.

```{r, warning = FALSE, message = FALSE}
# Assessing if alpha = 0.05
gs_path = system.file('extdata','vignette_genesets.txt', package='chipenrich')
results = chipenrich(peaks = peaks_E2F4, genome = 'hg19', genesets = gs_path,
	locusdef = "nearest_tss", qc_plots = FALSE, randomization = 'complete',
    out_name = NULL, n_cores = 1)
alpha = sum(results$results$P.value < 0.05) / nrow(results$results)
print(alpha)
```

# References

R.P. Welch^, C. Lee^, R.A. Smith, P. Imbriano, S. Patil, T. Weymouth, L.J. Scott, M.A. Sartor. "ChIP-Enrich: gene set enrichment testing for ChIP-seq data." Nucl. Acids Res. (2014) 42(13):e105. doi:10.1093/nar/gku463

R.G. Cavalcante, C. Lee, R.P. Welch, S. Patil, T. Weymouth, L.J. Scott, and M.A. Sartor. "Broad-Enrich: functional interpretation of large sets of broad genomic regions." Bioinformatics (2014) 30(17):i393-i400 doi:10.1093/bioinformatics/btu444
